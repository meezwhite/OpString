/**!
 * OpString
 * 
 * @version 0.2.0
 * @license MIT
 * @copyright meezwhite
 */
export default class OpString{version="0.2.0";#e="";#t=[];#r={};#i={};#s;#n=!1;#o=!1;#a=1;#h=0;#c=1;#u=2;#l=0;#g=65535;#p=["sequence","operations","values","maxSequenceLength","ignoreWarnings","strictMode"];constructor(e){try{this.#d("constructor",arguments),void 0!==e&&(void 0!==e.maxSequenceLength&&(this.#s=e.maxSequenceLength),"boolean"==typeof e.ignoreWarnings&&(this.#n=e.ignoreWarnings),"boolean"==typeof e.strictMode&&(this.#o=e.strictMode),void 0!==e.operations&&this.#y(e.operations),void 0!==e.values&&this.#m(e.values),void 0!==e.sequence&&this.setSequence(e.sequence))}catch(e){this.#f(e)}}append(e,t){const r=this.#a;try{return this.#d("append",arguments),this.#t.push({id:r,operation:this.#v(e),values:this.#b(t)}),this.#a++,this.#q(),r}catch(e){this.#f(e)}return null}insert(e,t,r){const i=this.#a;try{return this.#d("add",arguments),this.#t.splice(e,0,{id:i,operation:this.#v(t),values:this.#b(r)}),this.#a++,this.#q(),i}catch(e){this.#f(e)}return null}prepend(e,t){const r=this.#a;try{return this.#d("prepend",arguments),this.#t.unshift({id:r,operation:this.#v(e),values:this.#b(t)}),this.#a++,this.#q(),r}catch(e){this.#f(e)}return null}remove(e){try{this.#d("remove",arguments);const t=this.#t.findIndex((t=>t.id===e));if(-1===t)throw new ReferenceError(`Cannot remove operation with id ${e}, since not found.`);this.#t.splice(t,1),this.#q()}catch(e){return this.#f(e),!1}return!0}#v(e){return this.#S(e)===this.#c?e.charCodeAt(0):e}#b(e){return void 0!==e?e.map((e=>{const t=this.#S(e);return t===this.#c?e.charCodeAt(0):t===this.#u?e:null})):[]}#q(){let e="";for(let t=0;t<this.#t.length;t++){e+=String.fromCharCode(this.#t[t].operation);for(let r=0;r<this.#t[t].values.length;r++)e+=String.fromCharCode(this.#t[t].values[r])}this.#e=e}setSequence(e){let t=!1;try{this.#d("setSequence",arguments)}catch(e){t=!0,this.#f(e)}finally{if(!t||t&&!this.#o){this.#e=e,this.#t=[];for(let t=0;t<e.length;t++){const r=e.charCodeAt(t);if(this.#r[r]){const i=[];for(let r=t+1;r<e.length;r++){const t=e.charCodeAt(r);if(this.#i[t])i.push(t);else{if(this.#r[t])break;this.registerValue(t,null),i.push(t)}}this.#t.push({id:this.#a++,operation:r,values:i})}}}}}getSequence(){return this.#e}getSequenceData(){return this.#t}registerOperation(e,t){try{this.#d("registerOperation",arguments);const r=this.#S(e);r===this.#c?this.#r[e.charCodeAt(0)]=t:r===this.#u&&(this.#r[e]=t)}catch(e){this.#f(e)}}registerOperations(e){try{this.#d("registerOperations",arguments),this.#y(e)}catch(e){this.#f(e)}}#y(e){for(const[t,r]of Object.entries(e))this.registerOperation(t,r)}setOperations(e){try{this.#d("setOperations",arguments),this.#r={},this.#y(e)}catch(e){this.#f(e)}}getOperations(){return this.#r}registerValue(e,t){try{this.#d("registerValue",arguments);const r=this.#S(e);r===this.#c?this.#i[e.charCodeAt(0)]=t:r===this.#u&&(this.#i[e]=t)}catch(e){this.#f(e)}}registerValues(e){try{this.#d("registerValues",arguments),this.#m(e)}catch(e){this.#f(e)}}#m(e){for(const[t,r]of Object.entries(e))this.registerValue(t,r)}setValues(e){try{this.#d("setValues",arguments),this.#i={},this.#m(e)}catch(e){this.#f(e)}}getValues(){return this.#i}setMaxSequenceLength(e){try{this.#d("setMaxSequenceLength",arguments),this.#s=e}catch(e){this.#f(e)}}getMaxSequenceLength(){return this.#s}execute(e){const t=void 0===e;let r=!1;try{t?this.#d("executeMain",[this.#e]):this.#d("executeProvided",arguments)}catch(e){r=!0,this.#f(e)}finally{(!r||r&&!this.#o)&&(t?this.#T():this.#w(e))}}#w(e){"string"!=typeof e&&(e="");for(let t=0;t<e.length;t++){const r=this.#r[e.charCodeAt(t)];if(r){const i=[];for(let r=t+1;r<e.length;r++){const t=e.charCodeAt(r),s=this.#i[t];if(s)i.push(s);else{if(this.#r[t])break;i.push(void 0)}}r(...i)}}}#T(){for(let e=0;e<this.#t.length;e++){const t=this.#t[e].operation,r=this.#r[t];if(r){const t=[];for(let r=0;r<this.#t[e].values.length;r++){const i=this.#t[e].values[r],s=this.#i[i];if(s)t.push(s);else{if(this.#r[i])break;t.push(void 0)}}r(...t)}}}#S(e){const t=/^\d+$/.test(e);return t?this.#u:t||"string"!=typeof e?this.#h:this.#c}#C(e,t=[]){let r=!0;return 0!==t.length&&(r=Object.keys(e).every((e=>t.includes(e)))),"object"==typeof e&&null!==e&&!Array.isArray(e)&&Object.keys(e).length>0&&r&&void 0!==e.constructor&&e.constructor.prototype.hasOwnProperty("isPrototypeOf")}#x(e){return e>=this.#l&&e<=this.#g}#$(e){return"number"==typeof e&&Number.isSafeInteger(e)&&e>0}#E(e){return!(void 0!==this.#s&&e.length>this.#s)}#f(e){e=`[${this.constructor.name}] ${e.name}: ${e.message}`,this.#o?console.error(e):this.#n||console.warn(e)}#d(e,t){let r;switch(e){case"constructor":if(void 0!==t[0]){if(!this.#C(t[0],this.#p)){const e=this.#p.slice(0,-1).map((e=>`'${e}'`)).join(", "),t=this.#p[this.#p.length-1];throw new TypeError(`The 'config' parameter, if defined, must be a non-empty plain object with valid 'config' properties; these are ${e} and '${t}'.`)}if(void 0!==t[0].sequence&&"string"!=typeof t[0].sequence)throw new TypeError("The 'config.sequence' property, if defined, must be a string.");if(void 0!==t[0].operations&&!this.#C(t[0].operations))throw new TypeError("The 'config.operations' property, if defined, must be a non-empty plain object.");if(void 0!==t[0].values&&!this.#C(t[0].values))throw new TypeError("The 'config.values' property, if defined, must be a non-empty plain object");if(void 0!==t[0].maxSequenceLength&&!this.#$(t[0].maxSequenceLength))throw new TypeError("The 'config.maxSequenceLength' property, if defined, must be a positive safe integer.");if(void 0!==t[0].ignoreWarnings&&"boolean"!=typeof t[0].ignoreWarnings)throw new TypeError("The 'config.ignoreWarnings' property, if defined, must be a boolean.");if(void 0!==t[0].strictMode&&"boolean"!=typeof t[0].strictMode)throw new TypeError("The 'config.strictMode' property, if defined, must be a boolean.")}break;case"setSequence":if(r=this.#o?`Cannot ${e} to '${t[0]}'. The`:`Setting the sequence to '${t[0]}' despite exceeded length. The`,void 0!==t[0]&&"string"!=typeof t[0])throw new TypeError(`${r} sequence must be a string.`);if("string"==typeof t[0]&&!this.#E(t[0]))throw new RangeError(`${r} provided sequence exceeds the configured 'maxSequenceLength' of ${this.#s} characters.`);break;case"remove":if(!this.#$(t[0]))throw new TypeError(`Cannot remove operation with id '${t[0]}'. The id must be a positive safe integer.`);break;case"append":case"insert":case"prepend":case"registerOperation":case"registerValue":"insert"===e&&(t=[t[1],t[2],t[0]]);const i=["append","insert","prepend"].includes(e);if(r=`Cannot ${e}${i?" operation":""} with symbol '${t[0]}'`,"insert"===e){const e="number"==typeof t[2];if(!e||e&&t[2]<0)throw new TypeError(`${r} at index '${t[2]}'. The index must be a non-negative integer.`)}const s="symbol must be a string or an integer.",n="string symbol must consist of a single character.",o=`integer symbol must be within the range of ${this.#l} and ${this.#g}.`,a=this.#S(t[0]);if(a===this.#h)throw new TypeError(`${r}. The ${s}`);if(a===this.#c&&1!==t[0].length)throw new SyntaxError(`${r}. A ${n}`);if(a===this.#u&&!this.#x(t[0]))throw new RangeError(`${r}. An ${o}`);if(i&&void 0!==t[1]){const e=Array.isArray(t[1]);if(!e||e&&0===t[1].length)throw new TypeError(`${r}. The 'values' parameter must be an non-empty array.`);const i=` and values '${t[1]}'. The 'values' array contains an invalid symbol. Each `;for(let e=0;e<t[1].length;e++){const a=this.#S(t[1][e]);if(a===this.#h)throw new TypeError(`${r}${i}${s}`);if(a===this.#c&&1!==t[1][e].length)throw new SyntaxError(`${r}${i}${n}`);if(a===this.#u&&!this.#x(t[1][e]))throw new RangeError(`${r}${i}${o}`)}}if("registerOperation"===e){if("function"!=typeof t[1])throw new TypeError(`${r}. The 'callback' parameter must be a function.`)}else if("registerValue"===e&&void 0===t[1])throw new TypeError(`${r}. The 'value' parameter cannot be undefined.`);break;case"setOperations":case"registerOperations":case"setValues":case"registerValues":let h;if(["setOperations","registerOperations"].includes(e)?h="operations":["setValues","registerValues"].includes(e)&&(h="values"),!this.#C(t[0]))throw new TypeError(`Cannot ${e}, since the '${h}' parameter must be a non-empty plain object.`);break;case"setMaxSequenceLength":if(!this.#$(t[0]))throw new TypeError(`Cannot ${e}, since the 'maxSequenceLength' parameter must be a positive safe integer.`);break;case"executeMain":case"executeProvided":const c="executeProvided"===e?"provided":"";if(e="execute",r=this.#o?`Cannot ${e} the${c} sequence '${t[0]}'. The`:`Executing the${c} sequence '${t[0]}' despite exceeded length. The`,void 0!==t[0]&&"string"!=typeof t[0])throw new TypeError(`${r} sequence must be a string.`);if("string"==typeof t[0]){if(0===t[0].length)throw new SyntaxError("Cannot execute empty sequence.");if(!this.#E(t[0]))throw new RangeError(`${r}${c} sequence exceeds the configured 'maxSequenceLength' of ${this.#s} characters.`)}}}}
