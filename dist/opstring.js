/**!
 * OpString
 * 
 * @version 0.5.1
 * @license MIT
 * @copyright meezwhite
 */
export default class OpString{version="0.5.1";#e="";#t=[];#r={};#s={};#i={};#n;#o=!1;#a=!1;#h=1;#c=0;#l=1;#u=2;#g=0;#d=65535;#p=["sequence","operations","values","labels","maxSequenceLength","ignoreWarnings","strictMode"];constructor(e){try{this.#y("constructor",arguments),void 0!==e&&(void 0!==e.maxSequenceLength&&(this.#n=e.maxSequenceLength),"boolean"==typeof e.ignoreWarnings&&(this.#o=e.ignoreWarnings),"boolean"==typeof e.strictMode&&(this.#a=e.strictMode),void 0!==e.operations&&this.#f(e.operations),void 0!==e.values&&this.#m(e.values),void 0!==e.labels&&this.#b(e.labels),void 0!==e.sequence&&this.setSequence(e.sequence))}catch(e){this.#v(e)}}getNextId(){return this.#h}append(e,t){const r=this.#h;try{return this.#y("append",arguments),this.#t.push({id:r,operation:this.#C(e),values:this.#S(t)}),this.#h++,this.#q(),r}catch(e){this.#v(e)}return!1}insert(e,t,r){const s=this.#h;try{return this.#y("add",arguments),this.#t.splice(e,0,{id:s,operation:this.#C(t),values:this.#S(r)}),this.#h++,this.#q(),s}catch(e){this.#v(e)}return!1}prepend(e,t){const r=this.#h;try{return this.#y("prepend",arguments),this.#t.unshift({id:r,operation:this.#C(e),values:this.#S(t)}),this.#h++,this.#q(),r}catch(e){this.#v(e)}return!1}remove(e){try{this.#y("remove",arguments);const t=this.#t.findIndex((t=>t.id===e));if(-1===t)throw new ReferenceError(`Cannot remove operation with id ${e}, since not found.`);this.#t.splice(t,1),this.#q()}catch(e){return this.#v(e),!1}return!0}index(e){try{this.#y("index",arguments);const t=this.#t.findIndex((t=>t.id===e));if(-1!==t)return t;throw new ReferenceError(`Cannot find index of operation with id ${e}, since not found.`)}catch(e){this.#v(e)}}#C(e){return this.#w(e)===this.#l?e.charCodeAt(0):e}#S(e){return void 0!==e?e.map((e=>{const t=this.#w(e);return t===this.#l?e.charCodeAt(0):t===this.#u?e:null})):[]}#q(){let e="";for(let t=0;t<this.#t.length;t++){e+=String.fromCharCode(this.#t[t].operation);for(let r=0;r<this.#t[t].values.length;r++)e+=String.fromCharCode(this.#t[t].values[r])}this.#e=e}setSequence(e){let t=!1;try{this.#y("setSequence",arguments)}catch(e){t=!0,this.#v(e)}finally{if(!t||t&&!this.#a){this.#e=e,this.#t=[];for(let t=0;t<e.length;t++){const r=e.charCodeAt(t);if(this.#r[r]){const s=[];for(let r=t+1;r<e.length;r++){const t=e.charCodeAt(r);if(this.#s[t])s.push(t);else{if(this.#r[t])break;this.registerValue(t,null),s.push(t)}}this.#t.push({id:this.#h++,operation:r,values:s})}}}}}getSequence(){return this.#e}getSequenceData(){return this.#t}registerOperation(e,t){try{this.#y("registerOperation",arguments);const r=this.#w(e);r===this.#l?this.#r[e.charCodeAt(0)]=t:r===this.#u&&(this.#r[e]=t)}catch(e){this.#v(e)}}registerOperations(e){try{this.#y("registerOperations",arguments),this.#f(e)}catch(e){this.#v(e)}}#f(e){for(const[t,r]of Object.entries(e))this.registerOperation(t,r)}setOperations(e){try{this.#y("setOperations",arguments),this.#r={},this.#f(e)}catch(e){this.#v(e)}}getOperations(){return this.#r}registerValue(e,t){try{this.#y("registerValue",arguments);const r=this.#w(e);r===this.#l?this.#s[e.charCodeAt(0)]=t:r===this.#u&&(this.#s[e]=t)}catch(e){this.#v(e)}}registerValues(e){try{this.#y("registerValues",arguments),this.#m(e)}catch(e){this.#v(e)}}#m(e){for(const[t,r]of Object.entries(e))this.registerValue(t,r)}setValues(e){try{this.#y("setValues",arguments),this.#s={},this.#m(e)}catch(e){this.#v(e)}}getValues(){return this.#s}getCharForValue(e){try{this.#y("getCharForValue",arguments);const t=this.getCharCodeForValue(e);if(void 0!==t)return String.fromCharCode(t)}catch(e){this.#v(e)}}getCharCodeForValue(e){try{this.#y("getCharCodeForValue",arguments);const t=Object.keys(this.#s);for(let r=0;r<t.length;r++){const s=t[r];if(this.#s[s]===e)return s}}catch(e){this.#v(e)}}registerLabel(e,t){try{this.#y("registerLabel",arguments);const r=this.#w(t);r===this.#l?this.#i[e]=t.charCodeAt(0):r===this.#u&&(this.#i[e]=t)}catch(e){this.#v(e)}}registerLabels(e){try{this.#y("registerLabels",arguments),this.#b(e)}catch(e){this.#v(e)}}#b(e){for(const[t,r]of Object.entries(e))this.registerLabel(t,r)}setLabels(e){try{this.#y("setLabels",arguments),this.#i={},this.#b(e)}catch(e){this.#v(e)}}getLabels(){return this.#i}getCharForLabel(e){try{this.#y("getCharForLabel",arguments);const t=this.getCharCodeForLabel(e);if(void 0!==t)return String.fromCharCode(t)}catch(e){this.#v(e)}}getCharCodeForLabel(e){try{if(this.#y("getCharCodeForLabel",arguments),void 0!==this.#i[e])return this.#i[e]}catch(e){this.#v(e)}}setMaxSequenceLength(e){try{this.#y("setMaxSequenceLength",arguments),this.#n=e}catch(e){this.#v(e)}}getMaxSequenceLength(){return this.#n}execute(e){const t=void 0===e;let r=!1;try{t?this.#y("executeMain",[this.#e]):this.#y("executeProvided",arguments)}catch(e){r=!0,this.#v(e)}finally{(!r||r&&!this.#a)&&(t?this.#T():this.#x(e))}}#x(e){"string"!=typeof e&&(e="");for(let t=0;t<e.length;t++){const r=this.#r[e.charCodeAt(t)];if(r){const s=[];for(let r=t+1;r<e.length;r++){const t=e.charCodeAt(r),i=this.#s[t];if(void 0!==i)s.push(i);else{if(this.#r[t])break;s.push(void 0)}}r(...s)}}}#T(){for(let e=0;e<this.#t.length;e++){const t=this.#t[e].operation,r=this.#r[t];if(r){const t=[];for(let r=0;r<this.#t[e].values.length;r++){const s=this.#t[e].values[r],i=this.#s[s];if(void 0!==i)t.push(i);else{if(this.#r[s])break;t.push(void 0)}}r(...t)}}}#w(e){const t=/^\d+$/.test(e);return t?this.#u:t||"string"!=typeof e?this.#c:this.#l}#$(e,t=[]){let r=!0;return 0!==t.length&&(r=Object.keys(e).every((e=>t.includes(e)))),"object"==typeof e&&null!==e&&!Array.isArray(e)&&Object.keys(e).length>0&&r&&void 0!==e.constructor&&e.constructor.prototype.hasOwnProperty("isPrototypeOf")}#E(e){return e>=this.#g&&e<=this.#d}#L(e){return"number"==typeof e&&Number.isSafeInteger(e)&&e>0}#I(e){return!(void 0!==this.#n&&e.length>this.#n)}#v(e){e=`[${this.constructor.name}] ${e.name}: ${e.message}`,this.#a?console.error(e):this.#o||console.warn(e)}#y(e,t){let r;switch(e){case"constructor":if(void 0!==t[0]){if(!this.#$(t[0],this.#p)){const e=this.#p.slice(0,-1).map((e=>`'${e}'`)).join(", "),t=this.#p[this.#p.length-1];throw new TypeError(`The 'config' parameter, if defined, must be a non-empty plain object with valid 'config' properties; these are ${e} and '${t}'.`)}if(void 0!==t[0].sequence&&"string"!=typeof t[0].sequence)throw new TypeError("The 'config.sequence' property, if defined, must be a string.");if(void 0!==t[0].operations&&!this.#$(t[0].operations))throw new TypeError("The 'config.operations' property, if defined, must be a non-empty plain object.");if(void 0!==t[0].values&&!this.#$(t[0].values))throw new TypeError("The 'config.values' property, if defined, must be a non-empty plain object");if(void 0!==t[0].labels&&!this.#$(t[0].labels))throw new TypeError("The 'config.labels' property, if defined, must be a non-empty plain object");if(void 0!==t[0].maxSequenceLength&&!this.#L(t[0].maxSequenceLength))throw new TypeError("The 'config.maxSequenceLength' property, if defined, must be a positive safe integer.");if(void 0!==t[0].ignoreWarnings&&"boolean"!=typeof t[0].ignoreWarnings)throw new TypeError("The 'config.ignoreWarnings' property, if defined, must be a boolean.");if(void 0!==t[0].strictMode&&"boolean"!=typeof t[0].strictMode)throw new TypeError("The 'config.strictMode' property, if defined, must be a boolean.")}break;case"setSequence":if(r=this.#a?`Cannot ${e} to '${t[0]}'. The`:`Setting the sequence to '${t[0]}' despite exceeded length. The`,void 0!==t[0]&&"string"!=typeof t[0])throw new TypeError(`${r} sequence must be a string.`);if("string"==typeof t[0]&&!this.#I(t[0]))throw new RangeError(`${r} provided sequence exceeds the configured 'maxSequenceLength' of ${this.#n} characters.`);break;case"remove":if(!this.#L(t[0]))throw new TypeError(`Cannot remove operation with id '${t[0]}'. The id must be a positive safe integer.`);break;case"index":if(!this.#L(t[0]))throw new TypeError(`Cannot find index for operation with id '${t[0]}'. The id must be a positive safe integer.`);break;case"append":case"insert":case"prepend":case"registerOperation":case"registerValue":case"registerLabel":"insert"===e?t=[t[1],t[2],t[0]]:"registerLabel"===e&&(t=[t[1],t[0]]);const s=["append","insert","prepend"].includes(e);if(r=`Cannot ${e}${s?" operation":""} with symbol '${t[0]}'`,"insert"===e){const e="number"==typeof t[2];if(!e||e&&t[2]<0)throw new TypeError(`${r} at index '${t[2]}'. The index must be a non-negative integer.`)}else if("registerLabel"===e&&"string"!=typeof t[1])throw new TypeError(`${r}. The label must be a string.`);const i="symbol must be a string or an integer.",n="string symbol must consist of a single character.",o=`integer symbol must be within the range of ${this.#g} and ${this.#d}.`,a=this.#w(t[0]);if(a===this.#c)throw new TypeError(`${r}. The ${i}`);if(a===this.#l&&1!==t[0].length)throw new SyntaxError(`${r}. A ${n}`);if(a===this.#u&&!this.#E(t[0]))throw new RangeError(`${r}. An ${o}`);if(s&&void 0!==t[1]){const e=Array.isArray(t[1]);if(!e||e&&0===t[1].length)throw new TypeError(`${r}. The 'values' parameter must be an non-empty array.`);const s=` and values '${t[1]}'. The 'values' array contains an invalid symbol. Each `;for(let e=0;e<t[1].length;e++){const a=this.#w(t[1][e]);if(a===this.#c)throw new TypeError(`${r}${s}${i}`);if(a===this.#l&&1!==t[1][e].length)throw new SyntaxError(`${r}${s}${n}`);if(a===this.#u&&!this.#E(t[1][e]))throw new RangeError(`${r}${s}${o}`)}}if("registerOperation"===e){if("function"!=typeof t[1])throw new TypeError(`${r}. The 'callback' parameter must be a function.`)}else if("registerValue"===e&&void 0===t[1])throw new TypeError(`${r}. The 'value' parameter cannot be undefined.`);break;case"setOperations":case"registerOperations":case"setValues":case"registerValues":case"registerLabels":let h;if(["setOperations","registerOperations"].includes(e)?h="operations":["setValues","registerValues"].includes(e)?h="values":["setLabels","registerLabels"].includes(e)&&(h="labels"),!this.#$(t[0]))throw new TypeError(`Cannot ${e}, since the '${h}' parameter must be a non-empty plain object.`);break;case"getCharForValue":case"getCharCodeForValue":case"getCharForLabel":case"getCharCodeForLabel":const c=e.slice(-5);if(void 0===t[0])throw new TypeError(`Cannot get character${e===`getCharFor${c}`?"":" code"} for undefined ${c.toLowerCase()}.`);break;case"setMaxSequenceLength":if(!this.#L(t[0]))throw new TypeError(`Cannot ${e}, since the 'maxSequenceLength' parameter must be a positive safe integer.`);break;case"executeMain":case"executeProvided":const l="executeProvided"===e?"provided":"";if(e="execute",r=this.#a?`Cannot ${e} the${l} sequence '${t[0]}'. The`:`Executing the${l} sequence '${t[0]}' despite exceeded length. The`,void 0!==t[0]&&"string"!=typeof t[0])throw new TypeError(`${r} sequence must be a string.`);if("string"==typeof t[0]){if(0===t[0].length)throw new SyntaxError("Cannot execute empty sequence.");if(!this.#I(t[0]))throw new RangeError(`${r}${l} sequence exceeds the configured 'maxSequenceLength' of ${this.#n} characters.`)}}}}
